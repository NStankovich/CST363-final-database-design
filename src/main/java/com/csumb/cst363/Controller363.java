/***********************************************************
* STUDENT NAMES: Raymond Shum, Nicholas Stankovich
* GROUP: Group 8
* COURSE: CST 363
* DUE DATE: February 2, 2021
* INSTRUCTOR: Professor David Wisneski
* TA: Brandon Lee
* ASSIGNMENT: Project 2
************************************************************/

package com.csumb.cst363;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.StringTokenizer;

import javax.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class Controller363 {

   @Autowired
   private JdbcTemplate jdbcTemplate;

      /*
       * Doctor requests form to create new prescription.
       */
      @GetMapping("/prescription/new")
      public String newPrescripton(Model model) {
         model.addAttribute("prescription", new Prescription());
         return "prescription_create";
      }

      /*
       * Process the new prescription form. 1. Validate that Doctor SSN exists and
       * matches Doctor Name. 2. Validate that Patient SSN exists and matches Patient
       * Name. 3. Validate that Drug name exists. 4. Insert new prescription. Return
       * error message and the filled in prescription form or the prescription with
       * the rxid number generated by the database.
       */
      @PostMapping("/prescription")
      public String addPrescription(@Valid Prescription p, BindingResult result, Model model) {
         if (result.hasErrors()) {
            System.out.println("Binding error in addPrescription.");
         }
         System.out.println(p.toString()); // debug -- print form data to console

         try {
            Connection conn = jdbcTemplate.getDataSource().getConnection();

            // Calls private helper method to perform input validation
            if (addPrescriptionValidation(p, conn)) {
               String doctorID, patientID, drugID = "";

               // Queries database for DoctorID and updates instance variable
               PreparedStatement ps = conn.prepareStatement("SELECT doctorid FROM doctor WHERE ssn = ?");
               ps.setString(1, p.getDoctor_ssn());
               ResultSet rs = ps.executeQuery();
               rs.next();
               doctorID = rs.getString(1);

               // Queries database for PatientID and updates instance variable
               ps = conn.prepareStatement("SELECT patientid FROM patient WHERE ssn = ?");
               ps.setString(1, p.getPatient_ssn());
               rs = ps.executeQuery();
               rs.next();
               patientID = rs.getString(1);

               // Queries database for drugID and updates instance variable
               ps = conn.prepareStatement("SELECT drugID FROM drug WHERE tradename = ?");
               ps.setString(1, p.getDrugName());
               rs = ps.executeQuery();
               rs.next();
               drugID = rs.getString(1);

               // Inserts values of doctorid, patientid, drugid and localdate object into
               // database
               ps = conn.prepareStatement(
                     "INSERT INTO prescription(doctorid,patientid,drugid,prescribeddate,quantity) VALUES (?,?,?,?,?)");
               ps.setInt(1, Integer.parseInt(doctorID));
               ps.setInt(2, Integer.parseInt(patientID));
               ps.setInt(3, Integer.parseInt(drugID));
               ps.setString(4, LocalDate.now().toString());
               ps.setInt(5, p.getQuantity());

               // Sets error message if failed to insert row.
               if (ps.executeUpdate() != 1) {
                  p.setRxid("Error: Prescription was not created. Could not insert record.");
               }
               // If no error, then updates prescription id
               else {
                  ps = conn.prepareStatement("SELECT last_insert_id()");
                  rs = ps.executeQuery();
                  rs.next();
                  p.setRxid(rs.getString(1));
               }
            }

            model.addAttribute("prescription", p);
            return "prescription_show";
         } catch (SQLException se) {
            return se.getMessage();
         }
      }

      /**
       * Private helper function for addPrescription method. Performs input validation
       * on Patient SSN/Name, Doctor SSN/Name and the drug name.
       * 
       * @param p    Prescription object to be updated
       * @param conn Connection to MySQL database
       * @return TRUE if input is valid and FALSE otherwise
       */
      private boolean addPrescriptionValidation(Prescription p, Connection conn) {
         try {

            // Queries patient table for row containing matching SSN
            PreparedStatement ps = conn
                  .prepareStatement("" + "SELECT firstname, lastname, ssn " + "FROM patient " + "WHERE ssn = ?");
            ps.setString(1, p.getPatient_ssn());
            ResultSet rs = ps.executeQuery();

            // Return false if result set is empty (no matching SSN)
            if (!rs.next()) {
               p.setRxid("Error: No patient found with this SSN.");
               return false;
            }
            // Return false if provided patient name does not match name associated with
            // provided SSN
            else if (!(rs.getString(1) + " " + rs.getString(2)).toLowerCase()
                  .equals(p.getPatientName().toLowerCase())) {
               p.setRxid("Error: Patient name does not match SSN.");
               return false;
            }

            // Queries doctor table for row containing matching SSN
            ps = conn.prepareStatement("" + "SELECT firstname, lastname, ssn " + "FROM doctor " + "WHERE ssn = ?");
            ps.setString(1, p.getDoctor_ssn());
            rs = ps.executeQuery();

            // Returns false if result set is empty (no matching SSN)
            if (!rs.next()) {
               p.setRxid("Error: No doctor found with this SSN.");
               return false;
            }
            // Return false if provided doctor name does not match name associated with
            // provided SSN
            else if (!(rs.getString(1) + " " + rs.getString(2)).toLowerCase().equals(p.getDoctorName().toLowerCase())) {
               p.setRxid("Error: Doctor name does not match SSN.");
               return false;
            }

            // Queries drug table for tradename matching provided drug name
            ps = conn.prepareStatement("" + "SELECT tradename " + "FROM drug " + "WHERE tradename = ?");
            ps.setString(1, p.getDrugName());
            rs = ps.executeQuery();

            // Return false if empty set (tradename not found)
            if (!rs.next()) {
               p.setRxid("Error: No such drug exists in our records. Partial matches are not allowed.");
               return false;
            }
         } catch (SQLException se) {
            System.out.println(se.getMessage());
            return false;
         }

         return true;
      }

      /*
       * patient requests the form to fill a prescription
       */
      @GetMapping("/prescription/fill")
      public String getfillForm(Model model) {
         model.addAttribute("prescription", new Prescription());
         return "prescription_fill";
      }

      /*
       * process the prescription fill form 1. Validate that rxid, pharmacy name and
       * pharmacy address are entered and uniquely identify a prescript and one
       * pharmacy. 2. update prescription with pharmacyid, name and address. 3. update
       * prescription with today's date. Display updated prescription or if there is
       * an error show the form with an error message.
       */
      @PostMapping("/prescription/fill")
      public String processFillForm(@Valid Prescription p, BindingResult result, Model model) {
         if (result.hasErrors()) {
            System.out.println("Binding error in processFillForm.");
         }

         try {
            Connection conn = jdbcTemplate.getDataSource().getConnection();
            int insertedRows = 0;

            // Calls private helper method to check if input is valid
            if (fillPrescriptionValidation(p, conn)) {

               // Queries prescription table and updates doctor' name
               // and quantity of drug on prescription object
               PreparedStatement ps = conn.prepareStatement("" + "SELECT do.firstname, do.lastname, pr.quantity "
                     + "FROM prescription pr " + "INNER JOIN patient pa ON pr.patientid = pa.patientid "
                     + "INNER JOIN doctor do ON pr.doctorid = do.doctorid " + "WHERE pr.prescriptionid = ?");
               ps.setInt(1, Integer.parseInt(p.getRxid()));
               ResultSet rs = ps.executeQuery();
               rs.next();
               p.setDoctorName(rs.getString(1) + " " + rs.getString(2));
               p.setQuantity(Integer.parseInt(rs.getString(3)));

               // Queries fills table for row containing provided prescriptionid
               ps = conn.prepareStatement("" + "SELECT datefilled " + "FROM fills " + "WHERE prescriptionid = ?");
               ps.setString(1, p.getRxid());
               rs = ps.executeQuery();

               // If empty set (prescription has not been filled), then a record
               // is inserted into the fills table.
               if (!rs.next()) {
                  ps = conn.prepareStatement(
                        "" + "INSERT INTO fills(prescriptionid, pharmacyid, datefilled) " + "VALUES(?,?,?)");
                  ps.setInt(1, Integer.parseInt(p.getRxid()));
                  ps.setInt(2, Integer.parseInt(p.getPharmacyID()));
                  ps.setString(3, LocalDate.now().toString());
                  insertedRows = ps.executeUpdate();
               }

               // Sets error message if insertion was unsuccessful
               if (insertedRows != 1) {
                  p.setRxid("Error: Record could not be inserted.");
               } else {
                  // Queries database for fields present in the prescription_result
                  // form except for SSN (private information)
                  ps = conn.prepareStatement("WITH u(prescriptionid, pharmacyid, drugid, quantity, datefilled) AS ( "
                        + "SELECT f.prescriptionid, f.pharmacyid, pr.drugid, pr.quantity, f.datefilled "
                        + "FROM fills f " + "INNER JOIN prescription pr ON f.prescriptionid = pr.prescriptionid "
                        + "WHERE f.prescriptionid = ? ) "
                        + "SELECT u.quantity, ph.phonenumber, u.datefilled, dr.tradename, u.quantity*s.pharmacyprice "
                        + "FROM sells s " + "INNER JOIN u ON s.pharmacyid = u.pharmacyid AND s.drugid = u.drugid "
                        + "INNER JOIN pharmacy ph ON u.pharmacyid = ph.pharmacyid "
                        + "INNER JOIN drug dr ON u.drugid = dr.drugid");
                  ps.setString(1, p.getRxid());
                  rs = ps.executeQuery();

                  // Updates prescription object with result set values
                  rs.next();
                  p.setQuantity(rs.getInt(1));
                  p.setPharmacyPhone(rs.getString(2));
                  p.setDateFilled(rs.getString(3));
                  p.setDrugName(rs.getString(4));
                  p.setCost(rs.getDouble(5));
               }

            }
         } catch (SQLException se) {
            return se.getMessage();
         }
         model.addAttribute("prescription", p);
         return "prescription_show";

      }

      /**
       * Private helper method for processFillForm. Performs input validation on Rxid,
       * PharmacyName and PharmacyAddress.
       * 
       * @param p    Prescription object to be updated
       * @param conn Connection to MySQL database
       * @return TRUE if input is valid, FALSE otherwise
       */
      private boolean fillPrescriptionValidation(Prescription p, Connection conn) {

         // Return false if any form values are empty or if patient name is one
         // word
         if (p.getPatientName().indexOf(" ") == -1 || p.getRxid().equals("") || p.getPharmacyAddress().equals("")
               || p.getPharmacyName().equals("")) {
            p.setRxid(
                  "Error: Form cannot have empty values and patient name must contain first and last name separated by a space.");
            return false;
         }

         try {
            // Convert patient name into an array holding first and last names
            StringTokenizer st = new StringTokenizer(p.getPatientName());
            String[] names = new String[2];

            // Return false if string does not contain 2 words
            if (st.countTokens() != 2) {
               p.setRxid("Error: Patient name must be two words: first and last name.");
               return false;
            }

            // Populates array with first and last names
            for (int i = 0; i < names.length; i++) {
               names[i] = st.nextToken();
            }

            // Queries database to see if any records exist with provided patientid,
            // first and last names
            PreparedStatement ps = conn.prepareStatement("" + "SELECT COUNT(prescriptionid) " + "FROM prescription pr "
                  + "INNER JOIN patient pa ON pr.patientid = pa.patientid " + "WHERE prescriptionid = ? "
                  + "AND pa.firstname = ? " + "AND pa.lastname = ?");
            ps.setInt(1, Integer.parseInt(p.getRxid()));
            ps.setString(2, names[0]);
            ps.setString(3, names[1]);
            ResultSet rs = ps.executeQuery();

            // returns false if empty set
            if (!rs.next()) {
               p.setRxid("Error: No results found for this patient and prescription.");
               return false;
            }
            // returns false if result is 0 (no records found) or >1 (not unique)
            else if (Integer.parseInt(rs.getString(1)) == 0 || Integer.parseInt(rs.getString(1)) > 1) {
               p.setRxid("Error: No results found for this patient and prescription.");
               return false;
            }

            // Queries database for count of pharmacies associated with provided
            // name and address
            ps = conn.prepareStatement(
                  "" + "SELECT COUNT(pharmacyid), pharmacyid " + "FROM pharmacy " + "WHERE name = ? AND address = ?");
            ps.setString(1, p.getPharmacyName());
            ps.setString(2, p.getPharmacyAddress());
            rs = ps.executeQuery();

            // returns false if empty set
            if (!rs.next()) {
               p.setRxid("Error: No pharmacy found with this name and address.");
               return false;
            }
            // returns false if no pharmacy found or if pharmacy is not unique
            else if (Integer.parseInt(rs.getString(1)) == 0 || Integer.parseInt(rs.getString(1)) > 1) {
               p.setRxid("Error: No pharmacy found with this name and address.");
               return false;
            }

            // sets pharmacyid of prescription object after validation
            p.setPharmacyID(rs.getString(2));
         } catch (SQLException se) {
            System.out.println(se.getMessage());
            return false;
         }
         // Calls private helper method to determine if prescription can be filled
         // at selected pharmacy
         return doesPharmacySellDrug(p, conn);
      }

      /**
       * Private helper method for fillPrescriptionValidation. Checks to see if the
       * provided pharmacy sells the provided drug id.
       * 
       * @param p    Prescription object to be referenced for validation
       * @param conn Connection to MySQL database
       * @return TRUE if pharmacy sells the drug and FALSE otherwise
       */
      private boolean doesPharmacySellDrug(Prescription p, Connection conn) {
         try {

            // Queries database to see if provided prescription id can be filled'
            // at provided pharmacyid
            PreparedStatement ps = conn
                  .prepareStatement("" + "WITH u(prescriptionid, drugid, firstname, lastname) AS ( "
                        + "SELECT pr.prescriptionid, pr.drugid, pa.firstname, pa.lastname " + "FROM prescription pr "
                        + "INNER JOIN patient pa ON pr.patientid = pa.patientid " + "WHERE pr.prescriptionid = ?) "
                        + "SELECT * " + "FROM sells s " + "INNER JOIN u ON u.drugid = s.drugid "
                        + "INNER JOIN pharmacy ph on s.pharmacyid = ph.pharmacyid " + "WHERE ph.pharmacyid = ?");
            ps.setString(1, p.getRxid());
            ps.setString(2, p.getPharmacyID());
            ResultSet rs = ps.executeQuery();

            // Return false if empty set (pharmacy does not sell drug)
            if (!rs.next()) {
               p.setRxid("Error: This pharmacy does not sell the drug that has been prescribed.");
               return false;
            } else
               return true;

         } catch (SQLException se) {
            System.out.println(se.getMessage());
            return false;
         }
      }

      /*
       * process search request for quantity used for each drug for a given pharmacy.
       * input is pharmacyID, startDate and endDate output is drugName, quantity used
       * to fill prescriptions 1. validate pharmacyID
       */
      @GetMapping("/pharmacy")
      public String pharmacyReport(@RequestParam("pharmacyID") String pharmacyID, @RequestParam("drug") String drug,
            @RequestParam("startDate") String startDate, @RequestParam("endDate") String endDate, Model model) {
         System.out.println("pharamcy report. ID=" + pharmacyID + ", start=" + startDate + ", end=" + endDate); // for
                                                                                                                // debug

         ArrayList<ReportElement1> drugs = new ArrayList<>();

         try {
            Connection conn = jdbcTemplate.getDataSource().getConnection();

            // Queries pharmacy table with provided pharmacyid
            PreparedStatement ps = conn
                  .prepareStatement("" + "SELECT pharmacyid " + "FROM pharmacy " + "WHERE pharmacyid = ?");
            ps.setString(1, pharmacyID);
            ResultSet rs = ps.executeQuery();

            // If result set is empty, set error message
            if (!rs.next()) {
               pharmacyID = "Pharmacy does not exist.";
            } else {

               // Queries database for report elements listed on fda_report
               // Queries for partial matches of drug name
               ps = conn.prepareStatement("" + "SELECT dr.tradename, sum(quantity) " + "FROM prescription pr "
                     + "INNER JOIN drug dr ON pr.drugid = dr.drugid "
                     + "INNER JOIN fills f ON pr.prescriptionid = f.prescriptionid "
                     + "INNER JOIN pharmacy p on f.pharmacyid = p.pharmacyid "
                     + "WHERE p.pharmacyid = ? AND f.datefilled BETWEEN ? AND ? " + "AND dr.tradename LIKE ?"
                     + "GROUP BY dr.tradename");
               ps.setString(1, pharmacyID);
               ps.setString(2, startDate);
               ps.setString(3, endDate);
               ps.setString(4, drug + "%");
               rs = ps.executeQuery();

               // Adds all retrieved records to drugs arraylist
               while (rs.next()) {
                  drugs.add(new ReportElement1(rs.getString(1), Integer.parseInt(rs.getString(2))));
               }
            }
         } catch (SQLException se) {
            return se.getMessage();
         }

         model.addAttribute("startDate", startDate);
         model.addAttribute("endDate", endDate);
         model.addAttribute("pharmacyID", pharmacyID);
         model.addAttribute("report", drugs);
         return "pharmacy_report";
      }

      /*
       * process search request for FDA of quantity of drug prescribed by doctor input
       * is drugname, date range output is doctor name, quantity prescribed 1.
       * validate the drug name (it may be a partial name of a drug)
       */
      @GetMapping("/fda")
      public String fdaReport(@RequestParam("drug") String drug, @RequestParam("startDate") String startDate,
            @RequestParam("endDate") String endDate, Model model) {
         System.out.println("fda report. drug=" + drug + ", start=" + startDate + ", end=" + endDate); // for debug

         ArrayList<ReportElement1> drugs = new ArrayList<>();

         try {
            Connection conn = jdbcTemplate.getDataSource().getConnection();

            // Queries database for number of distinct records containing provided
            // drug name
            PreparedStatement ps = conn.prepareStatement(
                  "" + "SELECT COUNT(DISTINCT tradename), tradename " + "FROM drug " + "WHERE tradename LIKE ?");
            ps.setString(1, drug + "%");
            ResultSet rs = ps.executeQuery();

            // If result set is not empty and 1 distinct record is found, proceed
            if (rs.next() && Integer.parseInt(rs.getString(1)) == 1) {

               // drug is set to results of last query to complete partial matches
               drug = rs.getString(2);

               // Query database for elements requested by report
               ps = conn.prepareStatement("" + "SELECT do.doctorid, do.firstname, do.lastname, SUM(pr.quantity) "
                     + "FROM prescription pr " + "INNER JOIN doctor do ON pr.doctorid = do.doctorid "
                     + "INNER JOIN drug dr ON pr.drugid = dr.drugid " + "WHERE dr.tradename LIKE ? "
                     + "AND pr.prescribeddate BETWEEN ? AND ? " + "GROUP BY do.doctorid");
               ps.setString(1, drug + "%");
               ps.setString(2, startDate);
               ps.setString(3, endDate);
               rs = ps.executeQuery();

               // Add retrieved elements to drugs array list, concatenating names
               while (rs.next()) {
                  drugs.add(new ReportElement1(rs.getString(2) + " " + rs.getString(3), rs.getInt(4)));
               }

            } else {
               drug = "Error: Drug name either not unique or does not exist.";
            }
         } catch (SQLException se) {
            return se.getMessage();
         }

         model.addAttribute("startDate", startDate);
         model.addAttribute("endDate", endDate);
         model.addAttribute("drug", drug);
         model.addAttribute("report", drugs);
         return "fda_report";
      }

      /*
       * return JDBC Connection using jdbcTemplate in Spring Server
       */
      private Connection getConnection() throws SQLException {
         Connection conn = jdbcTemplate.getDataSource().getConnection();
         return conn;
      }

}
